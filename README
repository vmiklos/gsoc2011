= GSoC Diary

== 2011-05-23

We talked with Cedric and decided that I'll base my rtf import work on `master`
(as opposed to `libreoffice-3-4`). The motivation from my side was that
writerfilter - the module that will contain the new rtf import - uses gbuild on
master, so working on `master` avoids potential merge conflicts. The initial
clone takes time, so I cloned the repos earlier (on 19th) and now I have
(successfully) built master on my notebook.

Michael Stahl (Oracle) mailed me, mentioning that they started to port the rtf
import to writerfilter in the
http://hg.services.openoffice.org/hg/cws/rtftok01/[rtftok01] CWS. The good news
is that I built the CWS and a hello world even works here (almost, the color of
the text is blue, but that's a minor thing, I guess). The bad news is that they
wrote a lot of XSL code to achieve that, which will be hard to maintain. We
discussed this with Cedric, so far what we have:

- the basic idea of using the RTF spec in OOXML format as a base of the importer is fine.
- generating code from the model in multiple steps is OK, so the result of the
  first step will be checked in to the repo (the original model can't be
  checked in due to legal reasons) and the rest can be generated build-time.

It is not clear yet what to use for XML transformation. Possible candidates:

- XSL: this is what the Oracle guys did, building on top of it is nice, but it
  has its maintenance problems.
- Python/Perl: possible, but Python is not a build-requirement (reusing the
  internal Python is tricky), and my perl knowledge is weak.
- $$C++$$: obvious choice, but rewriting the existing ~ 2000 line of XSL code
  in $$C++$$ is boring.

So - XSL or $$C++$$? We'll probably decide tomorrow.

== 2011-05-24

We had a longer talk on IRC with Cedric yesterday evening. To summarize our
decisions:

- I'll avoid flex and XSL in the new rtf import
- The rtf spec has a sample rtf reader (starting from page 209), that will be a
  good start for parsing. I'll write it in a way that whenever it meets an
  unknown control world, it'll emit a TODO (using `OSL_TRACE`) so TODOs will
  continuously disappear as I progress.

We considered a few external libs, but they are in most cases too high-level:
given that I expect I can just pass most of the rtf control words to the domain
mapper, an API like the one of http://sourceforge.net/projects/librtf/[librtf]
is not that useful.

So, today I started writing the necessary code to get the stream which contains
the rtf data: the existing RtfFilter no longer calls into `sw` via UNO to
invoke the old rtf export, but creates the domain mapper for rtf and the new
RTFDocument class.

What I did (with compile-testing only) is creating an
RTFDocumentImpl::resolve() skeleton, my current target is to get it called.

The problem here is that whenever I call to the rtftok lib from RtfFilter,
somehow the component isn't loaded, ie. even docx import won't work. (No, no
build-time warning, no "unresolved symbol" error message, just a meaningless
"General Error. General input/output error.")

To debug such problems, I had to touch `osl/unx/module.c` inside the sal
module, and rebuidl with dbglevel=2 to get the OSL_TRACE() which prints out
dlopen() errors. And that showed the real problem:

----
Trace 1: "Error osl_loadModule: librtftokli.so: cannot open shared object file: No such file or directory
----

(Also, running ldd or the checkdll tool in the *install* dir helps, I ran it in
solver, where it does not.)

Obviously.. I forgot rtftok is a new lib, so I have to touch
scp2/source/ooo/file_library_ooo.scp and re-run `make dev-install`.

At the end of the day, I get:

----
$ ./soffice.bin --headless --convert-to foo --outdir ../../../lo-test-files/writer ../../../lo-test-files/writer/hello.rtf
Trace 30515/1: "virtual sal_Bool RtfFilter::filter(const com::sun::star::uno::Sequence<com::sun::star::beans::PropertyValue>&)"
Trace 30515/1: "virtual void writerfilter::rtftok::RTFDocumentImpl::resolve(writerfilter::Stream&)"
----

which is exactly what I wanted. The result can be even opened, though of course
it's an empty document at the moment.

== 2011-05-25

I introduced `RTFDocumentImpl::Strm()`, so reading a character from the input
stream is now using the same API what the exporter uses for writing the output.

I've read through Appendix A (How to write an RTF Reader) of the RTF spec, the
"Other Problem Areas" part was especially useful.

My first target is to import a hello world RTF. As expected, even that is not
trivial. I added code that detects RTF control words (and their parameters, if
there are any), so now the first string it finds is "Times New Roman" in the
font table. Of course, since it has no idea the font table is something
special, where even normal strings should not be displayed.

Finally I implemented a function that aggregates "text" characters to a string
buffer, so now I have output, like:

----
TODO handle chars 'Hello world!'"
----

== 2011-05-26

http://cgit.freedesktop.org/libreoffice/filters/commit/?id=07e389463c185f9083110016b46b5404e0d319ea[Fixed]
build of writerfilter when `DEBUG_LOGGING` is defined. Also discussed the
debug_setup.mk problem (the debug flags were not enabled in a debug build) with
David, that's fixed in master now. I also rebased my `filters` repo to have
those fixes.

Trying to find out why the logger creates empty xml files under /tmp. The
problem was that in RtfFilter::filter(), I opened the domainmapper logger, but
did not close it. Without that, not a single byte was written to the log. ;)

Implemented code to keep track of opening and closing braces, which pointed out
a bug (the last char of the document was parsed twice), fixed.

Next is to have a list of destination keywords: that's important because if a
keyword is a destination, then I should ignore the whole group, not just the
keyword itself, as with other types. To do that, I wrote a little script to
check the RTF spec what other keyword types are there.

Learned the hard way that extern arrays should be declared as:

----
extern RTFSymbol aRTFControlWords[];
----

ie the `[]` should be after the variable name, not after the type name.

At the end of the day the parser skips destinations which are known (are in the
table) but not handled. The target is still to recognize that the hello world
document has the only string "Hello World!". Right now the only missing but for
this is to handle `\*\foo`, where `\foo` is an unknwon keyword (not in the
table). I'll implement that tomorrow.

== 2011-05-27

Got a patch from Cedric to fix build from `tail_build`. Had a look at the
problem "xml files in /tmp are almost empty", it turns out I accidently rebuilt
the resourcemodel library with plain `make -sr`, on order to get the xml dumps,
I always need to:

----
make -sr dbglevel=2
----

Then I added support for `\*`, so now the parser recognizes that "Hello world!"
is the only text token in the document. The dmapper xml log has the "!" suffix,
but not writer itself. After checking what the docx importer does, it turned
out that `utext()` expects a `\r` at the end of each paragraph, which gets
dropped.  Once I did the same in the RTF importer, a document containing a
"Hello world!" is imported! :)

Then I spent some time separating runs from properties, as previously every run
was handled as a paragraph.

Next, I looked how character properties are handled: as an example I want to
handle *bold* characters. It turned out a lot of preparation is needed to do
so:

- the domain mapper takes a class implementing `writerfilter::Reference<Properties>`
- the class can register properties using a class implementing the `Sprm` interface
- the `Sprm` interface requires to store property parameters in a class
  implementing the `Value` interface

Once this was done, my test document containing a bold character was imported
properly, and I only needed to implement the reset of sprms at the end of a
group.
