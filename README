= GSoC Diary

== 2011-05-23

We talked with Cedric and decided that I'll base my rtf import work on `master`
(as opposed to `libreoffice-3-4`). The motivation from my side was that
writerfilter - the module that will contain the new rtf import - uses gbuild on
master, so working on `master` avoids potential merge conflicts. The initial
clone takes time, so I cloned the repos earlier (on 19th) and now I have
(successfully) built master on my notebook.

Michael Stahl (Oracle) mailed me, mentioning that they started to port the rtf
import to writerfilter in the
http://hg.services.openoffice.org/hg/cws/rtftok01/[rtftok01] CWS. The good news
is that I built the CWS and a hello world even works here (almost, the color of
the text is blue, but that's a minor thing, I guess). The bad news is that they
wrote a lot of XSL code to achieve that, which will be hard to maintain. We
discussed this with Cedric, so far what we have:

- the basic idea of using the RTF spec in OOXML format as a base of the importer is fine.
- generating code from the model in multiple steps is OK, so the result of the
  first step will be checked in to the repo (the original model can't be
  checked in due to legal reasons) and the rest can be generated build-time.

It is not clear yet what to use for XML transformation. Possible candidates:

- XSL: this is what the Oracle guys did, building on top of it is nice, but it
  has its maintenance problems.
- Python/Perl: possible, but Python is not a build-requirement (reusing the
  internal Python is tricky), and my perl knowledge is weak.
- $$C++$$: obvious choice, but rewriting the existing ~ 2000 line of XSL code
  in $$C++$$ is boring.

So - XSL or $$C++$$? We'll probably decide tomorrow.

== 2011-05-24

We had a longer talk on IRC with Cedric yesterday evening. To summarize our
decisions:

- I'll avoid flex and XSL in the new rtf import
- The rtf spec has a sample rtf reader (starting from page 209), that will be a
  good start for parsing. I'll write it in a way that whenever it meets an
  unknown control world, it'll emit a TODO (using `OSL_TRACE`) so TODOs will
  continuously disappear as I progress.

We considered a few external libs, but they are in most cases too high-level:
given that I expect I can just pass most of the rtf control words to the domain
mapper, an API like the one of http://sourceforge.net/projects/librtf/[librtf]
is not that useful.

So, today I started writing the necessary code to get the stream which contains
the rtf data: the existing RtfFilter no longer calls into `sw` via UNO to
invoke the old rtf export, but creates the domain mapper for rtf and the new
RTFDocument class.

What I did (with compile-testing only) is creating an
RTFDocumentImpl::resolve() skeleton, my current target is to get it called.

The problem here is that whenever I call to the rtftok lib from RtfFilter,
somehow the component isn't loaded, ie. even docx import won't work. (No, no
build-time warning, no "unresolved symbol" error message, just a meaningless
"General Error. General input/output error.")

To debug such problems, I had to touch `osl/unx/module.c` inside the sal
module, and rebuidl with dbglevel=2 to get the OSL_TRACE() which prints out
dlopen() errors. And that showed the real problem:

----
Trace 1: "Error osl_loadModule: librtftokli.so: cannot open shared object file: No such file or directory
----

(Also, running ldd or the checkdll tool in the *install* dir helps, I ran it in
solver, where it does not.)

Obviously.. I forgot rtftok is a new lib, so I have to touch
scp2/source/ooo/file_library_ooo.scp and re-run `make dev-install`.

At the end of the day, I get:

----
$ ./soffice.bin --headless --convert-to foo --outdir ../../../lo-test-files/writer ../../../lo-test-files/writer/hello.rtf
Trace 30515/1: "virtual sal_Bool RtfFilter::filter(const com::sun::star::uno::Sequence<com::sun::star::beans::PropertyValue>&)"
Trace 30515/1: "virtual void writerfilter::rtftok::RTFDocumentImpl::resolve(writerfilter::Stream&)"
----

which is exactly what I wanted. The result can be even opened, though of course
it's an empty document at the moment.

== 2011-05-25

I introduced `RTFDocumentImpl::Strm()`, so reading a character from the input
stream is now using the same API what the exporter uses for writing the output.

I've read through Appendix A (How to write an RTF Reader) of the RTF spec, the
"Other Problem Areas" part was especially useful.

My first target is to import a hello world RTF. As expected, even that is not
trivial. I added code that detects RTF control words (and their parameters, if
there are any), so now the first string it finds is "Times New Roman" in the
font table. Of course, since it has no idea the font table is something
special, where even normal strings should not be displayed.

Finally I implemented a function that aggregates "text" characters to a string
buffer, so now I have output, like:

----
TODO handle chars 'Hello world!'"
----

== 2011-05-26

http://cgit.freedesktop.org/libreoffice/filters/commit/?id=07e389463c185f9083110016b46b5404e0d319ea[Fixed]
build of writerfilter when `DEBUG_LOGGING` is defined. Also discussed the
debug_setup.mk problem (the debug flags were not enabled in a debug build) with
David, that's fixed in master now. I also rebased my `filters` repo to have
those fixes.

Trying to find out why the logger creates empty xml files under /tmp. The
problem was that in RtfFilter::filter(), I opened the domainmapper logger, but
did not close it. Without that, not a single byte was written to the log. ;)

Implemented code to keep track of opening and closing braces, which pointed out
a bug (the last char of the document was parsed twice), fixed.

Next is to have a list of destination keywords: that's important because if a
keyword is a destination, then I should ignore the whole group, not just the
keyword itself, as with other types. To do that, I wrote a little script to
check the RTF spec what other keyword types are there.

Learned the hard way that extern arrays should be declared as:

----
extern RTFSymbol aRTFControlWords[];
----

ie the `[]` should be after the variable name, not after the type name.

At the end of the day the parser skips destinations which are known (are in the
table) but not handled. The target is still to recognize that the hello world
document has the only string "Hello World!". Right now the only missing but for
this is to handle `\*\foo`, where `\foo` is an unknwon keyword (not in the
table). I'll implement that tomorrow.

== 2011-05-27

Got a patch from Cedric to fix build from `tail_build`. Had a look at the
problem "xml files in /tmp are almost empty", it turns out I accidently rebuilt
the resourcemodel library with plain `make -sr`, on order to get the xml dumps,
I always need to:

----
make -sr dbglevel=2
----

Then I added support for `\*`, so now the parser recognizes that "Hello world!"
is the only text token in the document. The dmapper xml log has the "!" suffix,
but not writer itself. After checking what the docx importer does, it turned
out that `utext()` expects a `\r` at the end of each paragraph, which gets
dropped.  Once I did the same in the RTF importer, a document containing a
"Hello world!" is imported! :)

Then I spent some time separating runs from properties, as previously every run
was handled as a paragraph.

Next, I looked how character properties are handled: as an example I want to
handle *bold* characters. It turned out a lot of preparation is needed to do
so:

- the domain mapper takes a class implementing `writerfilter::Reference<Properties>`
- the class can register properties using a class implementing the `Sprm` interface
- the `Sprm` interface requires to store property parameters in a class
  implementing the `Value` interface

Once this was done, my test document containing a bold character was imported
properly, and I only needed to implement the reset of sprms at the end of a
group.

== 2011-05-30

Implemented italic and underline character attributes, then dived into font
tables. The table has an entry for each used font. For each font, it contains:

- a font number: that will be used later to refer to this entry
- a type: so similar font can be used when the font is missing -- seems to be ignored by dmapper at the moment
- pitch of the font: fixed or variable
- character set: we send text to dmapper in OUString, so we need to use this locally
- name: for this, I had to extend my RTFValue class to handle OUString, not just int

(Also discussed with Cedric why do we have an Attribute and an Sprm map for the
properties. Answer is simple: there is no point, a cleanup getting rid of
Attribute would be nice. Till then - some properties go to Sprm, some go to
Attributes. So I added support for Attributes in my RTFReferenceProperties
class.)

To test that the table is really imported, I modified my hello world document
to have a second line with a custom font (which is not part of the default font
table) and indeed the custom font appears when opening the test doc. :)

Next, I looked at the color table. That's not something dmapper supports, just
like encodings, so the table is stored in the parser. I tested the
implementation with a test document containing a green word.

Finally started to work on the stylesheet table. Not counting the few
LO-specific keywords, in a hello-world doc an entry contains:

- the index of the stylesheet
- a 'based on' index (inheritance)
- a 'next' index (e.g. normal text after a heading)
- several paragraph properties
- a name at the end

Question: anyone knows what's the difference between
http://opengrok.libreoffice.org/xref/filters/writerfilter/source/dmapper/StyleSheetTable.cxx#418[NS_rtf::LN_XSTZNAME
and NS_rtf::LN_XSTZNAME1]? (For now I use NS_rtf::LN_XSTZNAME1, since that
seems to have an effect.)

Testing this feature is a bit tricky, since the exporter repeats the contents
of the style after a style control world -- to support clients lacking style
support. So after converting `hello.odt` to `hello.rtf`, I manually removed
those redundant control words.

At the end of the day the index, paragraph properties and name work fine, need
to check 'based on' and 'next' tomorrow.

I also wrote a http://cgit.freedesktop.org/~vmiklos/lo-gsoc/tree/TODO[TODO] of
what I have in my mind to implement as time passes by.

== 2011-06-01

Finished paragraph styles: `\snext` and `\sbasedon`. Implemented a few keywords
related to default values: `\pard` (restore defaults) and `\deflang`,
`\adeflang`, `\deff`.

Wanted to work on the info table (document creation time, modification time),
but turns out the domain mapper calls the
`com.sun.star.document.OOXMLDocumentPropertiesImporter` uno service, which
handles ooxml only. So later I'll need to do that on my own.

Started to work on character properties, my quite complete test doc in this
topic is
http://cgit.freedesktop.org/~vmiklos/lo-test-files/tree/writer/charprops.odt[here].
The first few ones were trivial toggle control words, but then came highlight,
that's more interesting. The token id is NS_sprm::LN_CShd, and it uses the
value's getProperties() method. That should return an object, then object->resolve()
is used, and there the object should pass a NS_ooxml::LN_CT_Shd_fill token (as
attributes, not sprms!) with an int value, containing the color.

The next problem was dmapper trying to convert the underlying color for some
reason. Looks like nobody used that codo so far (see
http://opengrok.libreoffice.org/search?q=0x6877[opengrok]), so I just
http://cgit.freedesktop.org/~vmiklos/lo-filters/commit/?id=8d2312d81b488e56599164f0112c09d9528f0c74[removed]
that conversion. After that, I could implement various underline types --
colored and uncolored.

Finally I implemented superscripts and subscripts (that took a while, due to
bug-hunting in RTFValue::Clone()).

== 2011-06-02

Finished character properties:

- rotated text
- small capitals
- fields: initially I just wanted to parse hyperlinks, but in fact there is
  nothing hyperlink-specific in the code, so it should cover other field types
  as well
- expanded spacing
- kerning (after
  http://cgit.freedesktop.org/~vmiklos/lo-filters/commit/?id=97973a7ba5188939869586188688f2467883aacf[fixing]
  the dmapper part)
- accent characters (over dot / over coma)
- half-height lines
- scale width

Then worked on character styles. This triggered an older bug: first, the parser
assumed if a keyword is in the keyword table, it's handled (the table is
generated from the spec, so this is obviously not the case). Second, I skipped
the keyword after a `\*` only in case it was a destination. I checked once
again the spec, and it clearly says every keyword should be skipped in that
situation.

The previously mentioned test doc had a few special symbols at the end, I
implemented those, and now the import of the test doc looks fine.

At the end of the day I started work on paragraph properties: the various
horizontal alignment control words are implemented.
