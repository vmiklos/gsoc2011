= GSoC Diary

== 2011-05-23

We talked with Cedric and decided that I'll base my rtf import work on `master`
(as opposed to `libreoffice-3-4`). The motivation from my side was that
writerfilter - the module that will contain the new rtf import - uses gbuild on
master, so working on `master` avoids potential merge conflicts. The initial
clone takes time, so I cloned the repos earlier (on 19th) and now I have
(successfully) built master on my notebook.

Michael Stahl (Oracle) mailed me, mentioning that they started to port the rtf
import to writerfilter in the
http://hg.services.openoffice.org/hg/cws/rtftok01/[rtftok01] CWS. The good news
is that I built the CWS and a hello world even works here (almost, the color of
the text is blue, but that's a minor thing, I guess). The bad news is that they
wrote a lot of XSL code to achieve that, which will be hard to maintain. We
discussed this with Cedric, so far what we have:

- the basic idea of using the RTF spec in OOXML format as a base of the importer is fine.
- generating code from the model in multiple steps is OK, so the result of the
  first step will be checked in to the repo (the original model can't be
  checked in due to legal reasons) and the rest can be generated build-time.

It is not clear yet what to use for XML transformation. Possible candidates:

- XSL: this is what the Oracle guys did, building on top of it is nice, but it
  has its maintenance problems.
- Python/Perl: possible, but Python is not a build-requirement (reusing the
  internal Python is tricky), and my perl knowledge is weak.
- $$C++$$: obvious choice, but rewriting the existing ~ 2000 line of XSL code
  in $$C++$$ is boring.

So - XSL or $$C++$$? We'll probably decide tomorrow.

== 2011-05-24

We had a longer talk on IRC with Cedric yesterday evening. To summarize our
decisions:

- I'll avoid flex and XSL in the new rtf import
- The rtf spec has a sample rtf reader (starting from page 209), that will be a
  good start for parsing. I'll write it in a way that whenever it meets an
  unknown control world, it'll emit a TODO (using `OSL_TRACE`) so TODOs will
  continuously disappear as I progress.

We considered a few external libs, but they are in most cases too high-level:
given that I expect I can just pass most of the rtf control words to the domain
mapper, an API like the one of http://sourceforge.net/projects/librtf/[librtf]
is not that useful.

So, today I started writing the necessary code to get the stream which contains
the rtf data: the existing RtfFilter no longer calls into `sw` via UNO to
invoke the old rtf export, but creates the domain mapper for rtf and the new
RTFDocument class.

What I did (with compile-testing only) is creating an
RTFDocumentImpl::resolve() skeleton, my current target is to get it called.

The problem here is that whenever I call to the rtftok lib from RtfFilter,
somehow the component isn't loaded, ie. even docx import won't work. (No, no
build-time warning, no "unresolved symbol" error message, just a meaningless
"General Error. General input/output error.")

To debug such problems, I had to touch `osl/unx/module.c` inside the sal
module, and rebuidl with dbglevel=2 to get the OSL_TRACE() which prints out
dlopen() errors. And that showed the real problem:

----
Trace 1: "Error osl_loadModule: librtftokli.so: cannot open shared object file: No such file or directory
----

(Also, running ldd or the checkdll tool in the *install* dir helps, I ran it in
solver, where it does not.)

Obviously.. I forgot rtftok is a new lib, so I have to touch
scp2/source/ooo/file_library_ooo.scp and re-run `make dev-install`.

At the end of the day, I get:

----
$ ./soffice.bin --headless --convert-to foo --outdir ../../../lo-test-files/writer ../../../lo-test-files/writer/hello.rtf
Trace 30515/1: "virtual sal_Bool RtfFilter::filter(const com::sun::star::uno::Sequence<com::sun::star::beans::PropertyValue>&)"
Trace 30515/1: "virtual void writerfilter::rtftok::RTFDocumentImpl::resolve(writerfilter::Stream&)"
----

which is exactly what I wanted. The result can be even opened, though of course
it's an empty document at the moment.

== 2011-05-25

I introduced `RTFDocumentImpl::Strm()`, so reading a character from the input
stream is now using the same API what the exporter uses for writing the output.

I've read through Appendix A (How to write an RTF Reader) of the RTF spec, the
"Other Problem Areas" part was especially useful.

My first target is to import a hello world RTF. As expected, even that is not
trivial. I added code that detects RTF control words (and their parameters, if
there are any), so now the first string it finds is "Times New Roman" in the
font table. Of course, since it has no idea the font table is something
special, where even normal strings should not be displayed.

Finally I implemented a function that aggregates "text" characters to a string
buffer, so now I have output, like:

----
TODO handle chars 'Hello world!'"
----

== 2011-05-26

http://cgit.freedesktop.org/libreoffice/filters/commit/?id=07e389463c185f9083110016b46b5404e0d319ea[Fixed]
build of writerfilter when `DEBUG_LOGGING` is defined. Also discussed the
debug_setup.mk problem (the debug flags were not enabled in a debug build) with
David, that's fixed in master now. I also rebased my `filters` repo to have
those fixes.

Trying to find out why the logger creates empty xml files under /tmp. The
problem was that in RtfFilter::filter(), I opened the domainmapper logger, but
did not close it. Without that, not a single byte was written to the log. ;)

Implemented code to keep track of opening and closing braces, which pointed out
a bug (the last char of the document was parsed twice), fixed.

Next is to have a list of destination keywords: that's important because if a
keyword is a destination, then I should ignore the whole group, not just the
keyword itself, as with other types. To do that, I wrote a little script to
check the RTF spec what other keyword types are there.

Learned the hard way that extern arrays should be declared as:

----
extern RTFSymbol aRTFControlWords[];
----

ie the `[]` should be after the variable name, not after the type name.

At the end of the day the parser skips destinations which are known (are in the
table) but not handled. The target is still to recognize that the hello world
document has the only string "Hello World!". Right now the only missing but for
this is to handle `\*\foo`, where `\foo` is an unknwon keyword (not in the
table). I'll implement that tomorrow.

== 2011-05-27

Got a patch from Cedric to fix build from `tail_build`. Had a look at the
problem "xml files in /tmp are almost empty", it turns out I accidently rebuilt
the resourcemodel library with plain `make -sr`, on order to get the xml dumps,
I always need to:

----
make -sr dbglevel=2
----

Then I added support for `\*`, so now the parser recognizes that "Hello world!"
is the only text token in the document. The dmapper xml log has the "!" suffix,
but not writer itself. After checking what the docx importer does, it turned
out that `utext()` expects a `\r` at the end of each paragraph, which gets
dropped.  Once I did the same in the RTF importer, a document containing a
"Hello world!" is imported! :)

Then I spent some time separating runs from properties, as previously every run
was handled as a paragraph.

Next, I looked how character properties are handled: as an example I want to
handle *bold* characters. It turned out a lot of preparation is needed to do
so:

- the domain mapper takes a class implementing `writerfilter::Reference<Properties>`
- the class can register properties using a class implementing the `Sprm` interface
- the `Sprm` interface requires to store property parameters in a class
  implementing the `Value` interface

Once this was done, my test document containing a bold character was imported
properly, and I only needed to implement the reset of sprms at the end of a
group.

== 2011-05-30

Implemented italic and underline character attributes, then dived into font
tables. The table has an entry for each used font. For each font, it contains:

- a font number: that will be used later to refer to this entry
- a type: so similar font can be used when the font is missing -- seems to be ignored by dmapper at the moment
- pitch of the font: fixed or variable
- character set: we send text to dmapper in OUString, so we need to use this locally
- name: for this, I had to extend my RTFValue class to handle OUString, not just int

(Also discussed with Cedric why do we have an Attribute and an Sprm map for the
properties. Answer is simple: there is no point, a cleanup getting rid of
Attribute would be nice. Till then - some properties go to Sprm, some go to
Attributes. So I added support for Attributes in my RTFReferenceProperties
class.)

To test that the table is really imported, I modified my hello world document
to have a second line with a custom font (which is not part of the default font
table) and indeed the custom font appears when opening the test doc. :)

Next, I looked at the color table. That's not something dmapper supports, just
like encodings, so the table is stored in the parser. I tested the
implementation with a test document containing a green word.

Finally started to work on the stylesheet table. Not counting the few
LO-specific keywords, in a hello-world doc an entry contains:

- the index of the stylesheet
- a 'based on' index (inheritance)
- a 'next' index (e.g. normal text after a heading)
- several paragraph properties
- a name at the end

Question: anyone knows what's the difference between
http://opengrok.libreoffice.org/xref/filters/writerfilter/source/dmapper/StyleSheetTable.cxx#418[NS_rtf::LN_XSTZNAME
and NS_rtf::LN_XSTZNAME1]? (For now I use NS_rtf::LN_XSTZNAME1, since that
seems to have an effect.)

Testing this feature is a bit tricky, since the exporter repeats the contents
of the style after a style control world -- to support clients lacking style
support. So after converting `hello.odt` to `hello.rtf`, I manually removed
those redundant control words.

At the end of the day the index, paragraph properties and name work fine, need
to check 'based on' and 'next' tomorrow.

I also wrote a http://cgit.freedesktop.org/~vmiklos/lo-gsoc/tree/TODO[TODO] of
what I have in my mind to implement as time passes by.

== 2011-06-01

Finished paragraph styles: `\snext` and `\sbasedon`. Implemented a few keywords
related to default values: `\pard` (restore defaults) and `\deflang`,
`\adeflang`, `\deff`.

Wanted to work on the info table (document creation time, modification time),
but turns out the domain mapper calls the
`com.sun.star.document.OOXMLDocumentPropertiesImporter` uno service, which
handles ooxml only. So later I'll need to do that on my own.

Started to work on character properties, my quite complete test doc in this
topic is
http://cgit.freedesktop.org/~vmiklos/lo-test-files/tree/writer/charprops.odt[here].
The first few ones were trivial toggle control words, but then came highlight,
that's more interesting. The token id is NS_sprm::LN_CShd, and it uses the
value's getProperties() method. That should return an object, then object->resolve()
is used, and there the object should pass a NS_ooxml::LN_CT_Shd_fill token (as
attributes, not sprms!) with an int value, containing the color.

The next problem was dmapper trying to convert the underlying color for some
reason. Looks like nobody used that codo so far (see
http://opengrok.libreoffice.org/search?q=0x6877[opengrok]), so I just
http://cgit.freedesktop.org/~vmiklos/lo-filters/commit/?id=8d2312d81b488e56599164f0112c09d9528f0c74[removed]
that conversion. After that, I could implement various underline types --
colored and uncolored.

Finally I implemented superscripts and subscripts (that took a while, due to
bug-hunting in RTFValue::Clone()).

== 2011-06-02

Finished character properties:

- rotated text
- small capitals
- fields: initially I just wanted to parse hyperlinks, but in fact there is
  nothing hyperlink-specific in the code, so it should cover other field types
  as well
- expanded spacing
- kerning (after
  http://cgit.freedesktop.org/~vmiklos/lo-filters/commit/?id=97973a7ba5188939869586188688f2467883aacf[fixing]
  the dmapper part)
- accent characters (over dot / over coma)
- half-height lines
- scale width

Then worked on character styles. This triggered an older bug: first, the parser
assumed if a keyword is in the keyword table, it's handled (the table is
generated from the spec, so this is obviously not the case). Second, I skipped
the keyword after a `\*` only in case it was a destination. I checked once
again the spec, and it clearly says every keyword should be skipped in that
situation.

The previously mentioned test doc had a few special symbols at the end, I
implemented those, and now the import of the test doc looks fine.

At the end of the day I started work on paragraph properties: the various
horizontal alignment (left, center, right, etc.) control words are implemented.

== 2011-06-03

Continued paragraph properties:

- indentation: left, right, first line
- spacing: before, after, between
- skipped register-true: looks like RTF does not support that
- skipped font alignment: that would be `NS_sprm::LN_PWAlignFont` and not
  implemented in the domain mapper; need to ask Cedric next week: how hard
  adding it would be
- window control
- background color
- paragraph border: this was a bit more complicated

  * the domain mapper assumed the tokens will be binary if it's not ooxml
  * the `\box` control word is before any other control word that would specify
    what kind of border do we want, so I had to make it possible to alter the
    attributes of an sprm after parsing it
  * there are 15 control words for the different border types, had to look up
    the exporter on how to map these to the `SvxBorderStyle` enum

- tabs: the next challange :)

  * the tab position is determined by a NS_ooxml::LN_CT_PPrBase_tabs sprms. It
    contains a NS_ooxml::LN_CT_Tabs_tab sprms for each tabstop. Finally the
    position value is defined by a NS_ooxml::LN_CT_TabStop_pos attribute.
  * the same true for other attributes (kind, leader) and they can appear in a
    random order. So my implementation creates the nested structure on-demand
    (when the first attribute arrives), that seems to work fine so far.

Other:

- Added support for hex characeters.
- Added initial support for non-ascii, non-utf8 characters.

At the end of the day, the paragraph properties
http://cgit.freedesktop.org/~vmiklos/lo-test-files/tree/writer/parprops.odt[test
document] is imported correctly, as far as I see.

What's next? I would like to continue with numbering on Monday.

== 2011-06-06

In RTF, numberings use 3 different layers:

- the "list table": think of this as a list of templates
- the "list override table": this instantiates the list templates
- finally the document body uses the `\ls` keyword to refer to entries from the
  list override table

One really annoying implementation detail here is that the list table contains
nested lists of properties, and so far I implemented the
`writerfilter::Reference<Properties>` interface as an `std::map<Id, Value>`,
which does not allow storing multiple Value elements of the same type. We
discussed this with Cedric and the conclusion is that I change the
implementation to allow multiple keys. First I wanted to use `std::vector`, but
later it turned out that `std::multimap` is a better choice here.

Other than that, there are multiple IDs here:

- There is a 'list table', here every entry has a 'listtemplateid' and 'list id'. There are entries inside each item, but those are not numbered.
- There is a 'list override table', that uses the 'list id' property to refer to an entry in the 'list table', and it also contains an 'ls' property, containing again an ID.
- Finally the body text uses 'ls' to refer to an entry in the 'list override table'.

Regarding how a numbering looks like, a standard `1.`, `2.`, etc. numbering
looks like this in RTF:

----
{\leveltext \'02\'00.;}
{\levelnumbers\'01;}
----

The same in DOCX:

----
      <w:numFmt w:val="decimal"/>
      <w:lvlText w:val="%1."/>
----

At the end of the day, the import of the above simple list is not ready, in
`/writerfilter/source/dmapper/NumberingManager.cxx:614` I catch an UNO
exception, which is sadly without a message. I'll debug it further. :)

== 2011-06-08

Worked on the `i18n.odt` test document, after fixing a bug in the hex parser
and implementing `\u`, it's now imported properly.

Back to numberings:

- my test document is now imported without errors
- the result still lacks numberings
- added pretty-print for sprm/attribute ids to xml dump
- reading xml dump, so far nothing really different to the docx dump that *is*
  imported properly
- reading resulting odf, list style (`WWNum-1`) is there, at least
- finally found, the NS_rtf::LN_LSID property should be an attribute, not an
  sprm ;)

As a result, import of bullet lists is now implemented.

Split the character and paragraph properties, this is needed because `\plain`
resets character properties, while `\pard` resets paragraph properties only.
This triggered a bug: dmapper ignores the parameter of the double strike
through character property (so actually this improves the docx import as well
:) ).

Tomorrow I plan to continue with numbered lists.

== 2011-06-09

Added support for the rest of the numbering types: "none" and "numbered".

Learned how to check if an `std::vector` contains an element
(http://cgit.freedesktop.org/~vmiklos/lo-gsoc/tree/test.cc[example]).

RTF and DOCX use a similar syntax to declare what syntax the numbering should
use, but they are a bit different. For a numbering like this:

----
1. foo
   1.1 bar
       1.1.1 baz
----

For the third line, DOCX uses:

----
<w:lvlText w:val=" %1.%2.%3 "/>
----

For the third line, RTF uses:

----
{\leveltext \'07 \'00.\'01.\'02 ;}
{\levelnumbers\'02\'04\'06;}
----

which can be converted for the dmapper to ` %1.%2.%3 ` without problems. The
troulbe is that in case you have a numbering like:

----
1. foo
   1. bar
----

Then DOCX uses:

----
<w:lvlText w:val="%2."/>
----

and RTF uses:

----
{\leveltext \'02\'01.;}
{\levelnumbers\'01;}
----

which will be converted to %1, not %2.

So I looked that the docx spec (17.9.12 describes `lvlText`), which explains
the semantics, then I could fix the RTF import.

Dived into pictures. As usual, I wanted to export the related odt test file (in
this case
http://cgit.freedesktop.org/~vmiklos/lo-test-files/tree/writer/picture.odt[picture.odt])
as docx and see how the domain mapper deals with it. Unfortunately it seems
dmapper is https://bugs.freedesktop.org/show_bug.cgi?id=38110[having problems]
with 'as character' pictures at the moment.

So instead exported the document in Word (as RTF and DOCX). The docx one is
parsed properly by dmapper. I stipped down manually the rtf one to include the
picture in PNG only (then later I can add support for fallbacking to WMF).

The testcase is ready, and I started poking the dmapper GraphicImport code. To
be continued.
