= GSoC Diary

== 2011-05-23

We talked with Cedric and decided that I'll base my rtf import work on `master`
(as opposed to `libreoffice-3-4`). The motivation from my side was that
writerfilter - the module that will contain the new rtf import - uses gbuild on
master, so working on `master` avoids potential merge conflicts. The initial
clone takes time, so I cloned the repos earlier (on 19th) and now I have
(successfully) built master on my notebook.

Michael Stahl (Oracle) mailed me, mentioning that they started to port the rtf
import to writerfilter in the
http://hg.services.openoffice.org/hg/cws/rtftok01/[rtftok01] CWS. The good news
is that I built the CWS and a hello world even works here (almost, the color of
the text is blue, but that's a minor thing, I guess). The bad news is that they
wrote a lot of XSL code to achieve that, which will be hard to maintain. We
discussed this with Cedric, so far what we have:

- the basic idea of using the RTF spec in OOXML format as a base of the importer is fine.
- generating code from the model in multiple steps is OK, so the result of the
  first step will be checked in to the repo (the original model can't be
  checked in due to legal reasons) and the rest can be generated build-time.

It is not clear yet what to use for XML transformation. Possible candidates:

- XSL: this is what the Oracle guys did, building on top of it is nice, but it
  has its maintenance problems.
- Python/Perl: possible, but Python is not a build-requirement (reusing the
  internal Python is tricky), and my perl knowledge is weak.
- $$C++$$: obvious choice, but rewriting the existing ~ 2000 line of XSL code
  in $$C++$$ is boring.

So - XSL or $$C++$$? We'll probably decide tomorrow.

== 2011-05-24

We had a longer talk on IRC with Cedric yesterday evening. To summarize our
decisions:

- I'll avoid flex and XSL in the new rtf import
- The rtf spec has a sample rtf reader (starting from page 209), that will be a
  good start for parsing. I'll write it in a way that whenever it meets an
  unknown control world, it'll emit a TODO (using `OSL_TRACE`) so TODOs will
  continuously disappear as I progress.

We considered a few external libs, but they are in most cases too high-level:
given that I expect I can just pass most of the rtf control words to the domain
mapper, an API like the one of http://sourceforge.net/projects/librtf/[librtf]
is not that useful.

So, today I started writing the necessary code to get the stream which contains
the rtf data: the existing RtfFilter no longer calls into `sw` via UNO to
invoke the old rtf export, but creates the domain mapper for rtf and the new
RTFDocument class.

What I did (with compile-testing only) is creating an
RTFDocumentImpl::resolve() skeleton, my current target is to get it called.

The problem here is that whenever I call to the rtftok lib from RtfFilter,
somehow the component isn't loaded, ie. even docx import won't work. (No, no
build-time warning, no "unresolved symbol" error message, just a meaningless
"General Error. General input/output error.")

To debug such problems, I had to touch `osl/unx/module.c` inside the sal
module, and rebuidl with dbglevel=2 to get the OSL_TRACE() which prints out
dlopen() errors. And that showed the real problem:

----
Trace 1: "Error osl_loadModule: librtftokli.so: cannot open shared object file: No such file or directory
----

(Also, running ldd or the checkdll tool in the *install* dir helps, I ran it in
solver, where it does not.)

Obviously.. I forgot rtftok is a new lib, so I have to touch
scp2/source/ooo/file_library_ooo.scp and re-run `make dev-install`.

At the end of the day, I get:

----
$ ./soffice.bin --headless --convert-to foo --outdir ../../../lo-test-files/writer ../../../lo-test-files/writer/hello.rtf
Trace 30515/1: "virtual sal_Bool RtfFilter::filter(const com::sun::star::uno::Sequence<com::sun::star::beans::PropertyValue>&)"
Trace 30515/1: "virtual void writerfilter::rtftok::RTFDocumentImpl::resolve(writerfilter::Stream&)"
----

which is exactly what I wanted. The result can be even opened, though of course
it's an empty document at the moment.

== 2011-05-24

I introduced `RTFDocumentImpl::Strm()`, so reading a character from the input
stream is now using the same API what the exporter uses for writing the output.

I've read through Appendix A (How to write an RTF Reader) of the RTF spec, the
"Other Problem Areas" part was especially useful.

My first target is to import a hello world RTF. As expected, even that is not
trivial. I added code that detects RTF control words (and their parameters, if
there are any), so now the first string it finds is "Times New Roman" in the
font table. Of course, since it has no idea the font table is something
special, where even normal strings should not be displayed.

Finally I implemented a function that aggregates "text" characters to a string
buffer, so now I have output, like:

----
TODO handle chars 'Hello world!'"
----
